select * from emp;
DECLARE
VNAME EMP.ENAME%TYPE; 
VSAL EMP.SAL%TYPE;
VJOB EMP.JOB%TYPE;

CURSOR NEW_CURSOR1(VDNO NUMBER)
IS
SELECT ENAME,SAL,JOB FROM EMP WHERE DEPTNO=VDNO  ;

BEGIN
OPEN NEW_CURSOR1(10);
LOOP
FETCH NEW_CURSOR1 INTO VNAME,VSAL,VJOB;
DBMS_OUTPUT.PUT_LINE(VNAME || ' ->: '||VSAL ||'->'||VJOB);
EXIT WHEN NEW_CURSOR1%NOTFOUND;
END LOOP;
DBMS_OUTPUT.PUT_LINE('ROW FETCHED = '|| NEW_CURSOR1%ROWCOUNT);
CLOSE NEW_CURSOR1;
END;

//TAKING VALUE FROM CONTEXT AREA(DIRECT TAKING)(WITHOUT DECLARING VARIABLES)
DECLARE

CURSOR CUR_EMP1 IS SELECT E.ENAME,E.SAL,E.JOB FROM EMP E;

BEGIN
    FOR REC IN CUR_EMP1
    LOOP
        DBMS_OUTPUT.PUT_LINE('name- '||REC.ENAME||'SALARY -- '||REC.SAL||' ROLE OF- '||REC.JOB);
        END LOOP;
        END;

//references cursors
//is ref cursor -keyword for thE REFERENCE CURSOR;

DECLARE
type REF_CUR_EMP IS REF CURSOR;
empdp_list ref_cur_emp;

VNAME VARCHAR2(30);
VSAL NUMBER;
VDNAME VARCHAR2(30);
VLOC VARCHAR2(20);

BEGIN
    OPEN empdp_list FOR SELECT E.ENAME,E.SAL FROM EMP E;
    DBMS_OUTPUT.PUT_LINE('LIST OF EMPLOYEES');
    DBMS_OUTPUT.PUT_LINE('_________________');
    LOOP

        FETCH empdp_list INTO VDNAME,VLOC;
        EXIT WHEN empdp_list%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE('NAME OF DELPARTMENT IS'||VDNAME||'LOCATION '||VLOC);
        END LOOP;
        CLOSE empdp_list;
        END;


 ///RETURN WILL BE TABLE ROW TYPE==(FULL TABLE RECORD)

 DECLARE

TYPE REF_CUR_DEPT IS REF CURSOR RETURN DEPT%ROWTYPE;

DEP_LIST REF_CUR_DEPT;
VDEP_ROW DEPT%ROWTYPE;

BEGIN
    OPEN DEP_LIST FOR SELECT * FROM DEPT;
    DBMS_OUTPUT.PUT_LINE('DEPARTMENT NAME LIST');
    DBMS_OUTPUT.PUT_LINE('_____________________');
    LOOP

        FETCH DEP_LIST INTO VDEP_ROW;
        EXIT WHEN DEP_LIST%NOTFOUND;

        DBMS_OUTPUT.PUT_LINE('DEPARTMENT NO = '||VDEP_ROW.DEPTNO);
        DBMS_OUTPUT.PUT_LINE('DEPARTMENT NAME = '|| VDEP_ROW.DNAME);
        DBMS_OUTPUT.PUT_LINE('DEPARTMENT LOCATION = '|| VDEP_ROW.LOC);

        DBMS_OUTPUT.PUT_LINE('______________________');
        END LOOP;
        CLOSE DEP_LIST;
        END;


      //procedures and functoins

   CREATE OR REPLACE PROCEDURE PROC_DEPT(
    IN_DEPTNO IN NUMBER,
    IN_DNAME IN VARCHAR2,
    IN_LOC IN VARCHAR2
   )
   AS
   BEGIN
    INSERT INTO DEPT(DEPTNO,DNAME,LOC) VALUES (IN_DEPTNO,IN_DNAME,IN_LOC);
    DBMS_OUTPUT.PUT_LINE('DEPARTMENT ADDED '|| IN_DEPTNO ||' SECCESSFULLY');
    END;

    BEGIN
        PROC_DEPT(70,'MARKETING','NEWYORK');
        END;
        SELECT * FROM DEPT;     

   //delete procedure

   CREATE or REPLACE PROCEDURE DELETE_DEPT
   (
    DEPID DEPT.DEPTNO%TYPE
   )
   AS
   BEGIN
    DELETE FROM DEPT WHERE DEPTNO=DEPID;
    DBMS_OUTPUT.PUT_LINE('DEPARTMENT DELETED ' || DEPID ||'SUCCESSFULLY');
    END;

    BEGIN
        DELETE_DEPT(70);
        END;     
        SELECT * FROM DEPT;

 //UPDATE PROCEDURE

 CREATE OR REPLACE PROCEDURE DEPT_UPDY(
    DEPID DEPT.DEPTNO%TYPE,
    DLOC DEPT.LOC%TYPE
 )       
 AS
 BEGIN
    UPDATE DEPT
    SET LOC=DLOC WHERE DEPTNO=DEPID;

    DBMS_OUTPUT.PUT_LINE('RECORD UPDATED...' || DEPID ||'SUCCESSFULLY....');
    END;

    BEGIN
        DEPT_UPDY(10,'HUSTON');
        END;

        //functoins

        CREATE OR REPLACE FUNCTION MYFUNC(A NUMBER,B NUMBER)
RETURN NUMBER
IS C NUMBER;
BEGIN
            C :=A*B;
           RETURN C;

END;

//CALLING A FUNCTION
DECLARE 
M NUMBER;
BEGIN
M:=MYFUNC(10,20);
DBMS_OUTPUT.PUT_LINE(M);
END;


//CODE FOR CREATING BACK TABLE;

create TABLE EMP_BACKUP AS SELECT * FROM EMP;

SELECT * FROM  EMP_BACKUP;

//CREATE TRIGGER

CREATE OR REPLACE TRIGGER TGR_DEL_EMP BEFORE DELETE ON EMP
FOR EACH ROW

BEGIN

INSERT INTO EMP_BACKUP VALUES
(:OLD.EMPNO,:OLD.ENAME,:OLD.JOB,:OLD.MGR,:OLD.HIREDATE,:OLD.SAL,:OLD.COMM,:OLD.DEPTNO);
DBMS_OUTPUT.PUT_LINE('TOOK BACK UP');
END;

DELETE  FROM EMP_BACKUP;
SELECT * FROM EMP;

DELETE FROM EMP WHERE EMPNO=7839;

INSERT INTO EMP 
VALUES (9876,'RAHUL','DEVELOPER',8900,'10-10-20',5000,NULL,3);

//SIMPLE TRIGGER FOR INSERT ON EMP 

CREATE OR REPLACE TRIGGER TGR_EMP_INSERT AFTER INSERT ON EMP FOR EACH ROW 
BEGIN
    DBMS_OUTPUT.PUT_LINE('A NEW RECORD INSERTED');
    END;

//SIMPLE TRIGGER FOR UPDATE ON EMP
CREATE OR REPLACE TRIGGER TGR_EMP_UPDATE AFTER UPDATE ON EMP FOR EACH ROW
BEGIN
    DBMS_OUTPUT.PUT_LINE('MY DATA IS UPDATED');
    END;


UPDATE EMP SET COMM=1 WHERE COMM IS NULL;

SELECT * FROM EMP;

-------------------------------------

ALTER TABLE_NAME DISABLE ALL TRIGGER;

ALTER TABLE_NAME ENABLE ALL TRIGGER;

ALTER TRIGGER TRIGGER_NAME ENABLE;---------SINGLE TRIGGER;

ALTER TRIGGER TRIGGER_NAME DISABLE;----------SINGLE TRIGGER;


// named oracle exception

DECLARE 

EMPNO EMP.EMPNO%TYPE;
EMPNAME EMP.ENAME%TYPE;
BEGIN
    SELECT ENAME INTO  EMPNAME
    FROM EMP WHERE EMPNO=100;
    exception WHEN NO_DATA_FOUND THEN
    DBMS_OUTPUT.PUT_LINE('EMPNO :DOSENT EXIST');
    END; 

    //

FETCH CUR_EMPDETAILS INTO VNAME,VSAL,VJOB;
IF CUR_EMPDETAILS%NOTFOUND THEN
RAISE NO_DATA_FOUND
ELSE 
LOOP
    FETCH CUR_EMPDETAILS INTO VNAME,VSAL,VJOB;
    EXIT WHEN CUR_EMPDETAILS%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE(VNAME || 'JOB IS '||VJOB||''||VSAL);
    END LOOP;
    END IF;
    CLOSE CUR_EMPDETAILS;
    exception
    WHEN NO_DATA_FOUND THEN 
    DBMS_OUTPUT.PUT_LINE('NO EMPLOYEES IN DEPTNO GIVEN');
    END;


    //
    DECLARE
    v_name VARCHAR2(50);
    BEGIN
        SELECT E.ENAME INTO V_NAME FROM EMP E;
        DBMS_OUTPUT.PUT_LINE('THE EMPLOYEE NAME IS '|| V_NAME);
        exception
        WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('NO DATA');
        WHEN TOO_MANY_ROWS THEN
        DBMS_OUTPUT.PUT_LINE('MANY ROWS');
        END;

        --------------------------------------------------------------------------------
        view
        select * from product;
        select * from student;
        select * from emp;
        SELECT * FROM DEPT;
        create or REPLACE view student_view as select * from student;
        select * from student_view;

        insert into student_view VALUES(431121,'dominic','kochi',9796977687,'5/02/2005','male',5,'04/04/2001',90);

        //view2
    


    CREATE OR REPLACE VIEW COM_EMP_DEP_VW as
    SELECT E.EMPNO,E.ENAME,E.JOB,E.HIREDATE,E.SAL,E.COMM,D.DEPTNO,D.DNAME,D.LOC 
    FROM EMP E JOIN DEPT D ON E.DEPTNO=D.DEPTNO;

    //VIEW CREATED;

    INSERT INTO COM_EMP_DEP_VW VALUES(10,'TOVINO','ACTOR','12/02/2001',2800,1,10,10,'ACCOUNTING','NEWYORK')
    //THIS CODE NOT WORK . SO WE CREATE A TRIGGER

    //INSTEAD CREATE A TRIGGER

    CREATE OR REPLACE TRIGGER TRG_EMPDP_VW
    INSTEAD OF INSERT ON COM_EMP_DEP_VW

    DECLARE
    CHECK_EXISTS NUMBER;
    BEGIN
        SELECT COUNT(*) INTO CHECK_EXISTS FROM DEPT D WHERE D.DEPTNO=:NEW.DEPTNO;
        IF CHECK_EXISTS =0 THEN
        INSERT INTO DEPT(DEPTNO,DNAME,LOC)VALUES(:NEW.DEPTNO,:NEW.DNAME,:NEW.LOC);
        END IF;

        INSERT INTO EMP(EMPNO,ENAME,JOB,HIREDATE,SAL,COMM,DEPTNO)
        VALUES(:NEW.EMPNO,:NEW.ENAME,:NEW.JOB,:NEW.HIREDATE,:NEW.SAL,:NEW.COMM,:NEW.DEPTNO);
        END;

SELECT * FROM COM_EMP_DEP_VW;

    INSERT INTO COM_EMP_DEP_VW VALUES(1000,'TOVINO','ACTOR','12/02/2001',2800,1,10,'ACCOUNTING','NEWYORK');


//ANOTHER VIEW

select * from student;
select * from class;

CREATE OR REPLACE VIEW STUDENT_CLASS AS
SELECT S.ADMNO,S.NAME,S.ADDRESS,S.PHONE_NO,S.DOB,S.GENDER,S.CLASS_ID,S.ADM_DATE,S.TMARKS,C.CLASS_NAME,C.SECTION,C.TEACHER_ID
FROM STUDENT S JOIN CLASS C ON S.CLASS_ID=C.CLASS_ID;

CREATE OR REPLACE TRIGGER STUDENT_CLASS_TRG 
INSTEAD OF INSERT ON STUDENT_CLASS
DECLARE
CHECK_EXISTS NUMBER;
BEGIN
    SELECT COUNT(*) INTO CHECK_EXISTS FROM CLASS WHERE CLASS.CLASS_ID=:NEW.CLASS_ID;
    IF CHECK_EXISTS=0 THEN
    INSERT INTO CLASS(CLASS_NAME,SECTION,TEACHER_ID)VALUES(:NEW.CLASS_NAME,:NEW.SECTION,:NEW.TEACHER_ID);
    END IF;

    INSERT INTO STUDENT(ADMNO,NAME,ADDRESS,PHONE_NO,DOB,GENDER,CLASS_ID,ADM_DATE,TMARKS)
    VALUES(:NEW.ADMNO,:NEW.NAME,:NEW.ADDRESS,:NEW.PHONE_NO,:NEW.DOB,:NEW.GENDER,:NEW.CLASS_ID,:NEW.ADM_DATE,:NEW.TMARKS);
    END;

SELECT * FROM STUDENT_CLASS;

INSERT INTO STUDENT_CLASS VALUES(431687,'INDORE','KANNIKARA',9096988687,'5/2/2003','MALE',4,'08/08/2003',89,'SECOND STANDSARD','B',3); 

//package
------------------------------------------
SELECT * FROM EMP;


CREATE OR REPLACE package EMP_PKG is
V_BONUS_RATE NUMBER :=0.10;

PROCEDURE ADD_EMP(P_EMPID IN NUMBER,P_NAME IN VARCHAR2,
P_JOB IN VARCHAR2,P_DOJ IN DATE,P_SAL IN NUMBER,P_COMM IN NUMBER,P_DEPID IN NUMBER);

FUNCTION CAL_BONUS(P_SAL IN NUMBER) RETURN NUMBER;
END EMP_PKG;

CREATE OR REPLACE package BODY EMP_PKG is
PROCEDURE ADD_EMP(P_EMPID IN NUMBER,P_NAME IN VARCHAR2,P_JOB IN VARCHAR2,P_DOJ IN DATE,P_SAL IN NUMBER,P_COMM IN NUMBER,P_DEPID IN NUMBER)
IS BEGIN

INSERT INTO EMP(EMPNO,ENAME,JOB,HIREDATE,SAL,COMM,DEPTNO)
VALUES(P_EMPID,P_NAME,P_JOB,P_DOJ,P_SAL,P_COMM,P_DEPID);
DBMS_OUTPUT.PUT_LINE('SUCCESSFULLY INSERTED üòÅ');
END;

FUNCTION CAL_BONUS(P_SAL IN NUMBER) RETURN NUMBER IS BONUS NUMBER;
BEGIN
    BONUS:=P_SAL *V_BONUS_RATE;
    RETURN BONUS;
    END;
END EMP_PKG;


-------------------------------------------------------------------


--CALLING PROCEDURE

BEGIN
    EMP_PKG.ADD_EMP(9024,'LAL-A10','ACTOR','12/2/2003',3000,3,20);
    END;

    DECLARE
    b_amt NUMBER;
    BEGIN
        b_amt := emp_pkg.cal_bonus(55000);
        DBMS_OUTPUT.PUT_LINE('bonus amount '||b_amt);
    end;